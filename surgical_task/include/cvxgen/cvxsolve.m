% Produced by CVXGEN, 2020-04-23 09:30:43 -0400.
% CVXGEN is Copyright (C) 2006-2017 Jacob Mattingley, jem@cvxgen.com.
% The code in this file is Copyright (C) 2006-2017 Jacob Mattingley.
% CVXGEN, or solvers produced by CVXGEN, cannot be used for commercial
% applications without prior written permission from Jacob Mattingley.

% Filename: cvxsolve.m.
% Description: Solution file, via cvx, for use with sample.m.
function [vars, status] = cvxsolve(params, settings)
if isfield(params, 'J_1')
  J_1 = params.J_1;
elseif isfield(params, 'J')
  J_1 = params.J{1};
else
  error 'could not find J_1'
end
if isfield(params, 'J_2')
  J_2 = params.J_2;
elseif isfield(params, 'J')
  J_2 = params.J{2};
else
  error 'could not find J_2'
end
if isfield(params, 'J_3')
  J_3 = params.J_3;
elseif isfield(params, 'J')
  J_3 = params.J{3};
else
  error 'could not find J_3'
end
if isfield(params, 'J_4')
  J_4 = params.J_4;
elseif isfield(params, 'J')
  J_4 = params.J{4};
else
  error 'could not find J_4'
end
if isfield(params, 'J_5')
  J_5 = params.J_5;
elseif isfield(params, 'J')
  J_5 = params.J{5};
else
  error 'could not find J_5'
end
if isfield(params, 'J_6')
  J_6 = params.J_6;
elseif isfield(params, 'J')
  J_6 = params.J{6};
else
  error 'could not find J_6'
end
if isfield(params, 'J_7')
  J_7 = params.J_7;
elseif isfield(params, 'J')
  J_7 = params.J{7};
else
  error 'could not find J_7'
end
damping = params.damping;
dqlow = params.dqlow;
dqup = params.dqup;
dt = params.dt;
dx = params.dx;
q = params.q;
qlow = params.qlow;
qup = params.qup;
slack = params.slack;
slacklow = params.slacklow;
slackup = params.slackup;
cvx_begin
  % Caution: automatically generated by cvxgen. May be incorrect.
  variable dq(7, 1);
  variable delta(7, 1);

  minimize(damping'*square(dq) + slack'*square(delta));
  subject to
    J_1(1)*dq(1) + J_1(2)*dq(2) + J_1(3)*dq(3) + J_1(4)*dq(4) + J_1(5)*dq(5) + J_1(6)*dq(6) + J_1(7)*dq(7) == dx(1) + delta(1);
    J_2(1)*dq(1) + J_2(2)*dq(2) + J_2(3)*dq(3) + J_2(4)*dq(4) + J_2(5)*dq(5) + J_2(6)*dq(6) + J_2(7)*dq(7) == dx(2) + delta(2);
    J_3(1)*dq(1) + J_3(2)*dq(2) + J_3(3)*dq(3) + J_3(4)*dq(4) + J_3(5)*dq(5) + J_3(6)*dq(6) + J_3(7)*dq(7) == dx(3) + delta(3);
    J_4(1)*dq(1) + J_4(2)*dq(2) + J_4(3)*dq(3) + J_4(4)*dq(4) + J_4(5)*dq(5) + J_4(6)*dq(6) + J_4(7)*dq(7) == dx(4) + delta(4);
    J_5(1)*dq(1) + J_5(2)*dq(2) + J_5(3)*dq(3) + J_5(4)*dq(4) + J_5(5)*dq(5) + J_5(6)*dq(6) + J_5(7)*dq(7) == dx(5) + delta(5);
    J_6(1)*dq(1) + J_6(2)*dq(2) + J_6(3)*dq(3) + J_6(4)*dq(4) + J_6(5)*dq(5) + J_6(6)*dq(6) + J_6(7)*dq(7) == dx(6) + delta(6);
    J_7(1)*dq(1) + J_7(2)*dq(2) + J_7(3)*dq(3) + J_7(4)*dq(4) + J_7(5)*dq(5) + J_7(6)*dq(6) + J_7(7)*dq(7) == dx(7) + delta(7);
    qlow(1) <= q(1) + dt*dq(1);
    qlow(2) <= q(2) + dt*dq(2);
    qlow(3) <= q(3) + dt*dq(3);
    qlow(4) <= q(4) + dt*dq(4);
    qlow(5) <= q(5) + dt*dq(5);
    qlow(6) <= q(6) + dt*dq(6);
    qlow(7) <= q(7) + dt*dq(7);
    q(1) + dt*dq(1) <= qup(1);
    q(2) + dt*dq(2) <= qup(2);
    q(3) + dt*dq(3) <= qup(3);
    q(4) + dt*dq(4) <= qup(4);
    q(5) + dt*dq(5) <= qup(5);
    q(6) + dt*dq(6) <= qup(6);
    q(7) + dt*dq(7) <= qup(7);
    dqlow(1) <= dq(1);
    dqlow(2) <= dq(2);
    dqlow(3) <= dq(3);
    dqlow(4) <= dq(4);
    dqlow(5) <= dq(5);
    dqlow(6) <= dq(6);
    dqlow(7) <= dq(7);
    dq(1) <= dqup(1);
    dq(2) <= dqup(2);
    dq(3) <= dqup(3);
    dq(4) <= dqup(4);
    dq(5) <= dqup(5);
    dq(6) <= dqup(6);
    dq(7) <= dqup(7);
    slacklow(1) <= delta(1);
    slacklow(2) <= delta(2);
    slacklow(3) <= delta(3);
    slacklow(4) <= delta(4);
    slacklow(5) <= delta(5);
    slacklow(6) <= delta(6);
    slacklow(7) <= delta(7);
    delta(1) <= slackup(1);
    delta(2) <= slackup(2);
    delta(3) <= slackup(3);
    delta(4) <= slackup(4);
    delta(5) <= slackup(5);
    delta(6) <= slackup(6);
    delta(7) <= slackup(7);
cvx_end
vars.delta = delta;
vars.dq = dq;
status.cvx_status = cvx_status;
% Provide a drop-in replacement for csolve.
status.optval = cvx_optval;
status.converged = strcmp(cvx_status, 'Solved');
